name "AWS Oracle RDS BYOSL"
rs_pt_ver 20180301
type "policy"
short_description "Check for Oracle RDS database instances that are set to the \"License Included\" license model. Remediation will update the license model to \"Bring Your Own License\" and reduce the per minute AWS rate for the Oracle instance since it's covered by a seperate Oracle agreement. See the [README](https://github.com/flexera/policy_templates/tree/master/cost/aws/rds_oracle_instance_byosl/) and [docs.rightscale.com/policies](https://docs.rightscale.com/policies/) to learn more."
long_description ""
severity "low"
category "Cost"
info(
  version: "2.0",
  provider: "AWS",
  service: "RDS",
  policy_set: "Configure Oracle RDS instances to BYOSL"
)

###############################################################################
# Permissions
###############################################################################

permission "perm_read_creds" do
  actions   "rs_cm.show_sensitive","rs_cm.index_sensitive"
  resources "rs_cm.credentials"
end

###############################################################################
# Parameters
###############################################################################

parameter "param_email" do
  type "list"
  label "Email addresses to notify"
  description "Email addresses of the recipients you wish to notify when new incidents are created"
end

parameter "param_exclusion_tag_key" do
  label "Exclusion Tag Key:Value"
  description "AWS tag key to ignore instances. Format: Key:Value"
  type "string"
end

###############################################################################
# Authentication
###############################################################################

#authenticate with AWS
credentials "auth_aws" do
  schemes "aws","aws_sts"
  label "AWS"
  description "Select the AWS Credential from the list."
  tags "provider=aws"
end

# auth "auth_aws", type: "aws" do
#   version 4
#   service "rds"
#   access_key cred('AWS_ACCESS_KEY_ID')
#   secret_key cred('AWS_SECRET_ACCESS_KEY')
# end

# auth "monitoring_auth_aws", type: "aws" do
#   version 4
#   service "monitoring"
#   access_key cred('AWS_ACCESS_KEY_ID')
#   secret_key cred('AWS_SECRET_ACCESS_KEY')
# end

###############################################################################
# Datasources
# Contains list of all AWS regions worldwide in a JSON file in GitHub
# https://raw.githubusercontent.com/rightscale/policy_templates/master/data/aws/regions.json
###############################################################################
datasource "ds_regions_list" do
  request do
    verb "GET"
    host "raw.githubusercontent.com"
    path "/rightscale/policy_templates/master/data/aws/regions.json"
    header "User-Agent", "RS Policies"
  end
end

###############################################################################
# Loop through all regions in ds_regions_list datasource to JavaScript to 
# retrieve all RDS instances into a datasource
###############################################################################
datasource "ds_instances_set" do
  iterate $ds_regions_list
  request do
    run_script $js_instances_set, val(iter_item,"region")
  end
  result do
    encoding "xml"
    collect xpath(response, "//DescribeDBInstancesResponse/DescribeDBInstancesResult/DBInstances/DBInstance[*]", "array") do
      field "availabilityZone", xpath(col_item,"AvailabilityZone")
      field "instanceId", xpath(col_item,"DbiResourceId")
      field "dbInstanceArn", xpath(col_item,"DBInstanceArn")
      field "dbInstanceIdentifier", xpath(col_item, "DBInstanceIdentifier")
      field "dbInstanceClass", xpath(col_item, "DBInstanceClass")
      field "engine", xpath(col_item, "Engine")
      field "region", val(iter_item, "region")
      field "licenseModel", xpath(col_item, "LicenseModel")
    end
  end
end

###############################################################################
# Loop through all RDS instances in ds_instances_set datasource and pass to 
# JavaScript with RDS instance ARN and region to retrieve any corresponding 
# tags. This data will be used to exclude RDS instances for right sizing.
###############################################################################
datasource "ds_list_tags_for_resource" do
  iterate $ds_instances_set
  request do
    run_script $js_list_tags_for_resource, val(iter_item,"dbInstanceArn"), val(iter_item,"region")
  end
  result do
    encoding "xml"
    collect xpath(response, "//ListTagsForResourceResponse/ListTagsForResourceResult/TagList/Tag[*]", "array") do
          field "instanceId", val(iter_item,"instanceId")
          field "key", xpath(col_item, "Key")
          field "value", xpath(col_item, "Value")
    end
  end
end

# get all the RDS instances merged together with the tags and CloudWatch

###############################################################################
# Run JavaScript with parameters of RDS instances in ds_instances_set, RDS
# instance tags in ds_list_tags_for_resource, Exclusion Tag Input to create a 
# new dataset that:
# a) removes any RDS instances with excluded tag
###############################################################################
datasource "ds_instances" do
  run_script $js_instances, $ds_instances_set, $ds_list_tags_for_resource, $param_exclusion_tag_key
end

###############################################################################
# Loop through all RDS instances in ds_instances (which exludes RDS instances 
# with exclude tags and includes upsize/downsize instance types for 
# rightsizing) datasource and pass to JavaScript with RDS instance region, 
# Identifier, and Cloudwatch CPU utilization metric type to retrieve each
# instance's CPU utilization and put the corresponding data into a new dataset
###############################################################################
datasource "ds_cloudwatch_cpu_usage" do
  iterate $ds_instances
  request do
    run_script $js_cloudwatch_cpu_mem_usage, val(iter_item, "region"), val(iter_item, "dbInstanceIdentifier"), "CPUUtilization"
  end
  result do
    encoding "json"
    collect jmes_path(response, "GetMetricStatisticsResponse.GetMetricStatisticsResult.Datapoints[*]") do
      field "region", val(iter_item, "region")
      field "instanceId", val(iter_item, "dbInstanceIdentifier")
      field "cpu_unit", jmes_path(col_item,"Unit")
      field "cpu_maximum", jmes_path(col_item, "Maximum")
      field "cpu_minimum", jmes_path(col_item, "Minimum")
      field "cpu_average", jmes_path(col_item, "Average")
    end
  end
end

###############################################################################
# Run JavaScript with parameters of RDS instances in ds_instances and RDS 
# instance CPU utilization in ds_cloudwatch_cpu_usage and merge CPU utilization
# into a new dataset
###############################################################################
datasource "ds_merged_metrics" do
  run_script $js_merged_metrics, $ds_instances, $ds_cloudwatch_cpu_usage
end

###############################################################################
# Run JavaScript with parameter of merged RDS instance data that includes 
# instance upsize/downsize values & CPU utilization and filter based on RDS 
# instance engine including "oracle" and license license model NOT set to 
# bring-your-own-license. This is our final result set that will be used for 
# notification and remediation.
###############################################################################
datasource "ds_filtered_results" do
  run_script $js_filtered_results, $ds_merged_metrics
end

###############################################################################
# Scripts
###############################################################################

script "js_instances", type: "javascript" do
  result "results"
  parameters "ds_instance_set", "ds_list_tags_for_resource", "param_exclusion_tag_key"
  code <<-EOS
  var tag_key = param_exclusion_tag_key.split(':')[0]
  var tag_value = param_exclusion_tag_key.split(':')[1]
  var results = []

  for ( n=0; n < ds_instance_set.length; n++) {
      //For each RDS instance examine datasource of corresponding RDS tags (keying off of instanceId in both datasets) and put into instance_tags data object
      var instance = ds_instance_set[n]

      var instances_w_tags = _.where(ds_list_tags_for_resource, {instanceId: instance.instanceId})
      var instance_tags = {}
      var tag_set = []
      _.each(instances_w_tags, function(instance){
        tag_set.push(instance.key+':'+instance.value)
      })
      instance_tags[instance.instanceId] = tag_set

      //If you encounter an RDS instance with excluded tag then exclude from JSON result set (eg: continue)
      if ( _.contains(instance_tags[instance.instanceId], param_exclusion_tag_key) ){
        continue
      } else {
        //Push into new JSON datasource
        results.push ({
          "region": instance.region,
          "availabilityZone": instance.availabilityZone,
          "dbInstanceArn": instance.dbInstanceArn,
          "dbInstanceIdentifier": instance.dbInstanceIdentifier,
          "dbInstanceClass": instance.dbInstanceClass,
          "engine": instance.engine,
          "licenseModel": instance.licenseModel
        })
      }

  }
EOS
end

script "js_instances_set", type: "javascript" do
  result "results"
  parameters "region"
  code <<-EOS
  results = {
    "auth": "auth_aws",
    "host": 'rds.'+region+'.amazonaws.com',
    "verb": "GET",
    "path": "/",
    "headers": {
      "User-Agent": "RS Policies",
      "Content-Type": "text/xml"
    }
    "query_params": {
      'Action': 'DescribeDBInstances',
      'Version': '2014-10-31'
    }
  }
EOS
end

script "js_list_tags_for_resource", type: "javascript" do
  result "results"
  parameters "instanceArn","region"
  code <<-EOS
  var end_date = new Date().toISOString()
  var start_date = new Date(new Date().setDate(new Date().getDate() - 30)).toISOString();
  results = {
    "auth": "auth_aws",
    "host": 'rds.'+region+'.amazonaws.com',
    "verb": "GET",
    "path": "/",
    "headers": {
      "User-Agent": "RS Policies",
      "Content-Type": "text/xml"
    }
    "query_params": {
      'Action': 'ListTagsForResource',
      'ResourceName': instanceArn,
      'Version': '2014-10-31'
    }
  }
EOS
end

script "js_cloudwatch_cpu_mem_usage", type: "javascript" do
  result "results"
  parameters "region","instance_id", "MetricName"
  code <<-EOS
  var end_date_tmp = new Date()
  end_date_tmp.setMilliseconds(0)
  end_date_tmp.setSeconds(0)
  end_date_tmp.setMinutes(0)
  var end_date = new Date(end_date_tmp).toISOString()

  var start_date_tmp = new Date(new Date().setDate(new Date().getDate() - 30))
  start_date_tmp.setMilliseconds(0)
  start_date_tmp.setSeconds(0)
  start_date_tmp.setMinutes(0)
  var start_date = new Date(start_date_tmp).toISOString()

  results = {
    "auth": "auth_aws",
    //"auth": "monitoring_auth_aws"
    "host": 'monitoring.'+region+'.amazonaws.com',
    "verb": "GET",
    "path": "/",
    "headers": {
      "User-Agent": "RS Policies",
      "Content-Type": "application/json",
      "x-amz-target": "GraniteServiceVersion20100801.GetMetricStatistics",
      "Accept": "application/json",
      "Content-Encoding": "amz-1.0"
    }
    "query_params": {
      'Action': 'GetMetricStatistics',
      'Version': '2010-08-01',
      'Namespace': 'AWS/RDS',
      'MetricName': MetricName,
      'Dimensions.member.1.Name': 'DBInstanceIdentifier',
      'Dimensions.member.1.Value': instance_id,
      'StartTime': start_date,
      'EndTime': end_date,
      'Period': "2592000",
      'Statistics.member.1': 'Maximum',
      'Statistics.member.2': 'Average',
      'Statistics.member.3': 'Minimum'
    }
  }
EOS
end

script "js_merged_metrics", type: "javascript" do
  parameters "ds_instances", "ds_cloudwatch_cpu_usage"
  result "results"
 code <<-EOS
 var results = []
 //For each RDS instance retrieve instanceID
 for (n=0; n < ds_instances.length; n++) {
   var instance = ds_instances[n]
   var dbInstanceIdentifier = instance["dbInstanceIdentifier"]
   //console.log("dbInstanceIdentifier is " + dbInstanceIdentifier)
   //Loop through the CPU data and match CPU data based on instanceID and put into cpu_average variable
   for (x=0; x < ds_cloudwatch_cpu_usage.length; x++) {
     var cpu_data=ds_cloudwatch_cpu_usage[x]
     var cpu_instanceid=cpu_data["instanceId"]
     //console.log("cpu_instanceid is " + cpu_instanceid)
     if (dbInstanceIdentifier == cpu_instanceid) {
      var cpu_average=parseFloat(cpu_data["cpu_average"]).toFixed(2)
      //console.log("cpu_average is " + cpu_average)
     }

   }
   //Push the results into new JSON dataset
   results.push (
     {
       "region": instance["region"],
       "availabilityZone": instance["availabilityZone"],
       "dbInstanceArn": instance["dbInstanceArn"],
       "dbInstanceIdentifier": instance["dbInstanceIdentifier"],
       "dbInstanceClass": instance["dbInstanceClass"],
       "engine": instance["engine"],
       "percent_cpu_avg": cpu_average,
       "licenseModel": instance["licenseModel"]       
     }
   )
 }
EOS
end


script "js_filtered_results", type: "javascript" do
  parameters "ds_merged_metrics"
  result "results"
  code <<-EOS
  var results = []
  _.each(ds_merged_metrics, function(instance){
    //For each instance only add to final dataset IF licensemodel is NOT set to bring-your-own-license AND an Oracle instance
	if ( (instance["licenseModel"] != "bring-your-own-license") && (instance["engine"].indexOf("oracle") !== -1) ){
        results.push (
          {
            "region": instance["region"],
            "availabilityZone": instance["availabilityZone"],
            "dbInstanceArn": instance["dbInstanceArn"],
            "dbInstanceIdentifier": instance["dbInstanceIdentifier"],
            "dbInstanceClass": instance["dbInstanceClass"],
            "engine": instance["engine"],
            "licenseModel": instance["licenseModel"],
            "percent_cpu_avg": instance["percent_cpu_avg"]
          }
        )
	}
  })

 EOS
end

###############################################################################
# Policy
###############################################################################

policy "pol_utilization" do
  validate $ds_filtered_results do
    summary_template "Oracle AWS RDS instances NOT set to BYOSL"
    detail_template <<-EOS
# Oracle AWS RDS instances NOT set to BYOSL
| Region | instanceID | Engine | Instance Class | Availability Zone | CPU Average % | License Type |
| ------ | ---------- | ------ | -------------- | ----------------- | ------------- | ------------ |
{{ range data -}}
| {{.region}} | {{.dbInstanceIdentifier}} | {{.engine}} | {{.dbInstanceClass}} |  {{.availabilityZone }} | {{ .percent_cpu_avg }} | {{ .licenseModel }} |
{{ end -}}

###### Policy Applied in Account: {{ rs_project_name }} (Account ID: {{ rs_project_id }}) within Org: {{ rs_org_name }} (Org ID: {{ rs_org_id }})
EOS
    check eq(size(data),0)
    escalate $email
    escalate $update_license
  end
end

###############################################################################
# Escalations
###############################################################################

escalation "email" do
  email $param_email
end

escalation "update_license" do
  request_approval  do
    label "Escalation approval"
    description "Approve Oracle RDS License update action"
    parameter "approval_reason" do
      type "string"
      label "Reason for approval"
      description "Explain why you are approving the action"
    end
  end
  run "update_rds_license", data
end

define update_rds_license($data) return $all_responses do
  $$debug=true
  $$log = []
  $all_responses = []

  $syslog_subject = "AWS Oracle RDS Instances to update: "
  call sys_log(join([$syslog_subject, "Identified Instances"]),to_s($data))
  foreach $item in $data do
    sub on_error: skip do
      $get_response = http_request(
        auth: $$auth_aws,
		https: true,
        verb: "get",
        host: "rds."+$item["region"]+".amazonaws.com",
        href: "/",
        query_strings: {
          "Action": "DescribeDBInstances",
          "Version": "2014-10-31",
          "DBInstanceIdentifier": $item["dbInstanceIdentifier"]
        }
      )
      $all_responses << $get_response

      $state = $get_response["body"]["DescribeDBInstancesResponse"]["DescribeDBInstancesResult"]["DBInstances"]["DBInstance"]["DBInstanceStatus"]

      if $state == "available"
        $modify_response = http_request(
          auth: $$auth_aws,
		  https: true,
          verb: "get",
          host: "rds."+$item["region"]+".amazonaws.com",
          href: "/",
          query_strings: {
            "Action": "ModifyDBInstance",
            "Version": "2014-10-31",
            "DBInstanceIdentifier": $item["dbInstanceIdentifier"],
            # Remove comment below to apply update immediately v. during maintenance window
            # "ApplyImmediately": true,
            "LicenseModel": "bring-your-own-license"
          }
        )
        $all_responses << $modify_response
      end
    end
  end
  call sys_log(join([$syslog_subject, "Responses"]),to_s($all_responses))
end

define handle_error($response) do
  $status_code = $response["code"]
  if $status_code == 404
    $_error_behavior = "skip"
  else
    $_error_behavior = "raise"
  end
end

define sys_log($subject, $detail) do
  if $$debug
    rs_cm.audit_entries.create(
      notify: "None",
      audit_entry: {
        auditee_href: @@account,
        summary: $subject,
        detail: $detail
      }
    )
  end
end
